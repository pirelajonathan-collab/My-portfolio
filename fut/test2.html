<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penales Pro - Ultimate Stadium</title>
    <style>
        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 60px rgba(0,0,0,1);
            border: 4px solid #222;
            border-radius: 4px;
            overflow: hidden;
            background: #111;
        }

        canvas { display: block; cursor: crosshair; image-rendering: pixelated; }

        /* UI Elements */
        .scoreboard {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.9); border: 2px solid #fff;
            padding: 8px 15px; color: white; border-radius: 4px;
            font-family: 'Courier New', monospace;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.5);
            z-index: 10;
        }
        .score-row { font-size: 14px; font-weight: bold; display: flex; justify-content: space-between; width: 160px; text-transform: uppercase; }
        .score-val { color: #00E676; } .score-val.miss { color: #FF3D00; }

        .ui-layer {
            position: absolute; bottom: 20px; width: 100%;
            display: flex; justify-content: space-between; align-items: flex-end;
            padding: 0 30px; box-sizing: border-box; pointer-events: none;
            z-index: 10;
        }

        .left-controls {
            pointer-events: auto; display: flex; flex-direction: column; gap: 15px; align-items: center;
        }

        /* Bot√≥n Tigre */
        .tiger-btn {
            width: 60px; height: 60px; border-radius: 50%; border: 3px solid #555;
            background: #222; color: #555; font-size: 30px; cursor: not-allowed;
            display: flex; justify-content: center; align-items: center;
            transition: all 0.3s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); position: relative;
        }
        .tiger-btn.unlocked {
            border-color: #FF5722; background: linear-gradient(135deg, #FF5722, #FFC107);
            color: white; cursor: pointer; animation: pulseTiger 1.5s infinite; box-shadow: 0 0 15px #FF5722;
        }
        .tiger-btn.active { transform: scale(0.95); box-shadow: inset 0 0 10px black; border-color: #FFF; }
        @keyframes pulseTiger {
            0% { box-shadow: 0 0 0 0 rgba(255, 87, 34, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(255, 87, 34, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 87, 34, 0); }
        }

        .effect-panel {
            display: flex; flex-direction: column; align-items: center; gap: 5px;
            background: rgba(0,0,0,0.8); padding: 10px; border: 2px solid #fff;
            border-radius: 8px; width: 100px; box-shadow: 4px 4px 0 #000;
        }
        .effect-title { color: #29B6F6; font-weight: 900; font-size: 11px; letter-spacing: 1px; }
        
        .dial-container {
            position: relative; width: 60px; height: 60px; border-radius: 50%;
            background: #333; border: 3px solid #777; cursor: ew-resize;
        }
        .dial-knob {
            position: absolute; top: 50%; left: 50%; width: 100%; height: 100%;
            transform: translate(-50%, -50%) rotate(0deg); pointer-events: none;
            display: flex; justify-content: center; align-items: center;
            color: #fff; font-size: 24px; font-weight: bold;
        }
        .dial-marker { position: absolute; top: 0; width: 6px; height: 10px; background: #29B6F6; }
        .effect-value { color: white; font-weight: bold; font-size: 14px; font-family: monospace; }

        .controls-info {
            background: rgba(0, 0, 0, 0.6); color: #fff; padding: 8px 20px;
            border: 1px solid #555; font-size: 11px; font-weight: bold;
            text-transform: uppercase; text-align: center; border-radius: 4px;
            letter-spacing: 1px;
        }

        .rival-panel {
            background: rgba(0,0,0,0.8); padding: 10px 20px; border: 2px solid #fff;
            border-radius: 8px; text-align: right; box-shadow: 4px 4px 0 #000;
        }
        .rival-name { color: #FFD600; font-size: 18px; font-weight: 900; display: block; text-shadow: 2px 2px 0 #000; letter-spacing: 1px; }

        #status-container { position: absolute; top: 30%; left: 0; width: 100%; display: flex; justify-content: center; pointer-events: none; z-index: 20;}
        .status-msg {
            font-size: 80px; font-weight: 900; text-transform: uppercase;
            font-family: 'Verdana', sans-serif; opacity: 0; transform: scale(0);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            -webkit-text-stroke: 4px black; color: white;
        }
        .status-msg.show { opacity: 1; transform: scale(1); }
        .gol { color: #00E676; text-shadow: 0 0 20px #00E676; }
        .atajada { color: #FF1744; text-shadow: 0 0 20px #FF1744; }
        .fuera { color: #FF9100; text-shadow: 0 0 20px #FF9100; }
        .zone { color: #FFD600; text-shadow: 0 0 30px #FFD600; font-style: italic; font-size: 90px; }
        .tiger-text { 
            color: #FF3D00; background: linear-gradient(to bottom, #FF9100, #FF3D00);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 61, 0, 1); font-style: italic;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="900" height="600"></canvas>
    <div id="status-container"><div id="status-text" class="status-msg">GOL!</div></div>
    
    <div class="scoreboard">
        <div class="score-row">Anotados <span class="score-val" id="score-goals">0</span></div>
        <div class="score-row">Fallados <span class="score-val miss" id="score-misses">0</span></div>
        <div class="score-row" style="margin-top:5px; font-size:10px; color:#aaa;">Racha Fallos: <span id="miss-streak">0</span>/5</div>
        <div class="score-row" style="margin-top:2px; font-size:10px; color:#FFD600;">Combo: <span id="combo-streak">0</span>/3</div>
    </div>
    
    <div class="ui-layer">
        <div class="left-controls">
            <div id="btn-tiger" class="tiger-btn" title="Disparo de Tigre (5 fallos)">üî•</div>
            <div class="effect-panel">
                <div class="effect-title">EFECTO</div>
                <div class="dial-container" id="dial">
                    <div class="dial-knob" id="dial-knob"><div class="dial-marker"></div><span>‚ü≥</span></div>
                </div>
                <div class="effect-value" id="effect-display">0%</div>
            </div>
        </div>
        <div class="controls-info">Arrastra el mouse para apuntar</div>
        <div class="rival-panel">
            <span style="color:#aaa; font-size:10px;">RIVAL</span>
            <span class="rival-name">SUPER PIXEL FC</span>
        </div>
    </div>
</div>

<script>
    // --- PALETA COLORES ---
    const C = { _: null, S: '#ffcc8d', S2: '#e5b67a', H: '#3e2723', U1: '#01579B', U2: '#0277BD', U3: '#4FC3F7', G1: '#1B5E20', G2: '#4CAF50', K: '#111', W: '#eee', O: '#FFF', N: '#FFD600' };

    // --- SPRITES ---
    // Jugador
    const spritePlayer = [[C._,C._,C._,C._,C.H,C.H,C.H,C.H,C._,C._,C._,C._],[C._,C._,C._,C.H,C.H,C.H,C.H,C.H,C.H,C._,C._,C._],[C._,C._,C.S,C.S,C.S2,C.S,C.S,C.S2,C.S,C.S,C._,C._],[C._,C.U2,C.U1,C.U1,C.U1,C.U1,C.U1,C.U1,C.U1,C.U2,C._],[C._,C.U2,C.U2,C.U1,C.U1,C.U1,C.U1,C.U1,C.U2,C.U2,C._],[C.S,C.U2,C.U2,C.U1,C.N,C.N,C.N,C.U1,C.U2,C.U2,C.S],[C.S,C.U2,C.U2,C.U1,C.N,C.U1,C.N,C.U1,C.U2,C.U2,C.S],[C.S,C.U2,C.U2,C.U1,C.N,C.N,C.N,C.U1,C.U2,C.U2,C.S],[C._,C._,C.W,C.W,C.W,C.W,C.W,C.W,C._,C._],[C._,C._,C.W,C.W,C.W,C.W,C.W,C.W,C._,C._],[C._,C._,C.S,C.S2,C._,C._,C.S,C.S2,C._,C._],[C._,C._,C.S,C.S2,C._,C._,C.S,C.S2,C._,C._],[C._,C._,C.U1,C.U1,C._,C._,C.U1,C.U1,C._,C._],[C._,C._,C.K,C.K,C._,C._,C.K,C.K,C._,C._]];
    const spritePlayerRun1 = [[C._,C._,C._,C._,C.H,C.H,C.H,C.H,C._,C._,C._,C._],[C._,C._,C._,C.H,C.H,C.H,C.H,C.H,C.H,C._,C._,C._],[C._,C._,C.S,C.S,C.S2,C.S,C.S,C.S2,C.S,C.S,C._,C._],[C._,C.U2,C.U1,C.U1,C.U1,C.U1,C.U1,C.U1,C.U1,C.U2,C._],[C.S,C.U2,C.U2,C.U1,C.U1,C.U1,C.U1,C.U1,C.U2,C.U2,C.S],[C.S,C.U2,C.U2,C.U1,C.N,C.N,C.N,C.U1,C.U2,C.U2,C.S],[C.S,C.U2,C.U2,C.U1,C.N,C.U1,C.N,C.U1,C.U2,C.U2,C.S],[C._,C.U2,C.U2,C.U1,C.N,C.N,C.N,C.U1,C.U2,C.U2,C._],[C._,C._,C.W,C.W,C.W,C.W,C.W,C.W,C._,C._],[C._,C._,C.W,C.W,C.W,C.W,C.W,C.W,C._,C._],[C._,C._,C._,C.S,C.S2,C.S,C.S2,C._,C._,C._],[C._,C._,C.S,C.S,C._,C._,C.S,C.S,C._,C._],[C._,C._,C.U1,C.U1,C._,C._,C.U1,C.U1,C._,C._],[C._,C._,C.K,C.K,C._,C._,C._,C.K,C.K,C._]];
    const spritePlayerRun2 = [[C._,C._,C._,C._,C.H,C.H,C.H,C.H,C._,C._,C._,C._],[C._,C._,C._,C.H,C.H,C.H,C.H,C.H,C.H,C._,C._,C._],[C._,C._,C.S,C.S,C.S2,C.S,C.S,C.S2,C.S,C.S,C._,C._],[C._,C.U2,C.U1,C.U1,C.U1,C.U1,C.U1,C.U1,C.U1,C.U2,C._],[C.S,C.U2,C.U2,C.U1,C.U1,C.U1,C.U1,C.U1,C.U2,C.U2,C.S],[C.S,C.U2,C.U2,C.U1,C.N,C.N,C.N,C.U1,C.U2,C.U2,C.S],[C.S,C.U2,C.U2,C.U1,C.N,C.U1,C.N,C.U1,C.U2,C.U2,C.S],[C._,C.U2,C.U2,C.U1,C.N,C.N,C.N,C.U1,C.U2,C.U2,C._],[C._,C._,C.W,C.W,C.W,C.W,C.W,C.W,C._,C._],[C._,C._,C.W,C.W,C.W,C.W,C.W,C.W,C._,C._],[C._,C._,C.S,C.S,C._,C._,C.S,C.S,C._,C._],[C._,C._,C.S,C.S,C._,C._,C.S,C.S,C._,C._],[C._,C._,C.U1,C.U1,C._,C._,C.U1,C.U1,C._,C._],[C._,C.K,C.K,C._,C._,C._,C._,C.K,C.K,C._]];
    const spritePlayerKick = [[C._,C._,C._,C._,C.H,C.H,C.H,C.H,C._,C._,C._,C._],[C._,C._,C._,C.H,C.H,C.H,C.H,C.H,C.H,C._,C._,C._],[C._,C._,C.S,C.U2,C.U1,C.U1,C.U1,C.U2,C.S,C._,C._],[C._,C._,C.S,C.U2,C.U1,C.U1,C.U1,C.U2,C.S,C._,C._],[C._,C._,C.U2,C.U2,C.U1,C.N,C.N,C.U2,C.U2,C._,C._],[C._,C._,C.W,C.W,C.W,C.W,C.W,C.W,C._,C._],[C._,C._,C.W,C.W,C.W,C.W,C.W,C.W,C.W,C.W,C._,C._],[C._,C._,C.S,C.S2,C._,C._,C.S,C.S,C.K,C.K],[C._,C._,C.U1,C.U1,C._,C._,C.U1,C.U1,C._,C._],[C._,C._,C.K,C.K,C._,C._,C._,C._,C._,C._]];
    // Portero
    const spriteGoalie = [[C._,C._,C._,C.H,C.H,C.H,C.H,C._,C._,C._],[C._,C._,C.S2,C.S,C.S,C.S,C.S,C.S2,C._,C._],[C._,C.G2,C.G1,C.G1,C.G1,C.G1,C.G1,C.G1,C.G2,C._],[C.O,C.G2,C.G1,C.G2,C.G2,C.G2,C.G2,C.G1,C.G2,C.O],[C.O,C.G2,C.G1,C.G1,C.G1,C.G1,C.G1,C.G1,C.G2,C.O],[C._,C.S,C.K,C.K,C.K,C.K,C.K,C.K,C.S,C._],[C._,C._,C.S,C.S,C._,C._,C.S,C.S,C._,C._],[C._,C._,C.W,C.W,C._,C._,C.W,C.W,C._,C._],[C._,C._,C.K,C.K,C._,C._,C.K,C.K,C._,C._],];
    const spriteGoalieDive = [[C._,C._,C._,C._,C._,C._,C.H,C.H,C.H,C._,C._,C._],[C._,C.O,C.O,C._,C._,C.O,C.S,C.S,C.S,C._,C._,C._],[C.O,C.G2,C.G1,C.G1,C.G1,C.G1,C.G1,C.G1,C.G1,C._,C._],[C.O,C.G2,C.G1,C.G1,C.G1,C.G1,C.G1,C.G1,C.G1,C._,C._],[C._,C._,C._,C.K,C.K,C.K,C.K,C.K,C.K,C._,C._,C._],[C._,C._,C._,C._,C.S,C.S,C._,C._,C.S,C.S,C.K,C.K]];
    // Fotografo (NPC)
    const spritePhoto = [
        [C._,C.W2,C.K,C.K,C.W2,C._],[C._,C.S,C.S,C.S,C.S,C._],[C._,C.K,C.W2,C.W2,C.K,C._],[C.K,C.K,C.W2,C.W2,C.K,C.K],[C._,C.U1,C.U1,C.U1,C.U1,C._]
    ];
    // Seguridad (NPC)
    const spriteGuard = [
        [C._,C.H,C.H,C._],[C._,C.S,C.S,C._],[C.O,C.O,C.O,C.O],[C._,C.O,C.O,C._],[C._,C.K,C.K,C._]
    ];

    function drawSprite(ctx, sprite, x, y, scale, rotation = 0) {
        ctx.save(); ctx.translate(x, y); ctx.rotate(rotation);
        const height = sprite.length; const width = sprite[0].length;
        const offsetX = -(width * scale) / 2; const offsetY = -(height * scale) / 2;
        for (let row = 0; row < height; row++) {
            for (let col = 0; col < width; col++) {
                if (sprite[row][col]) {
                    ctx.fillStyle = sprite[row][col];
                    ctx.fillRect(offsetX + col * scale, offsetY + row * scale, scale + 0.5, scale + 0.5);
                }
            }
        }
        ctx.restore();
    }

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('status-text');
    ctx.imageSmoothingEnabled = false; 

    // Estado
    let playerStats = { goals: 0, misses: 0, streak: 0 };
    let gameState = 'AIMING'; 
    const keys = { a: false, d: false };
    let time = 0;
    
    // Elementos Ambientales
    let flashes = []; // C√°maras
    let adBoards = [
        {text: "PIXEL COLA", color: "#F44336"}, 
        {text: "BIT BURGER", color: "#FF9800"}, 
        {text: "JS MOTORS", color: "#2196F3"},
        {text: "RETRO BET", color: "#4CAF50"}
    ];
    let confetti = [];

    // TIGER SHOT
    let tigerUnlocked = false;
    let isTigerShot = false;
    let netOnFire = false;
    let fireParticles = [];

    // Disparo
    let isCharging = false;
    let chargePower = 0; 
    let shootTarget = { x: 0, y: 0 };
    let spinValue = 0; 
    let isDraggingDial = false;
    let isCrowdCelebrating = false;
    let isGoalieActive = true; 
    
    let lastShotData = null; 
    let comboCounter = 0; 
    let inTheZoneShotsLeft = 0; 
    let lastZoneIndex = -1;
    let zoneRepetitionCount = 0; 

    const field = {
        horizonY: 180,
        goalLineY: 220,
        goalWidth: 260,
        goalHeight: 120,
        penaltySpotY: 400 
    };

    const ball = {
        x: canvas.width / 2, y: field.penaltySpotY, 
        groundX: canvas.width / 2, groundY: field.penaltySpotY, z: 0,
        radius: 12, scale: 1, vx: 0, vy: 0, vz: 0, shadowVy: 0, ax: 0,
        rotation: 0, trail: [] 
    };

    const player = { x: canvas.width / 2, y: canvas.height - 50, speed: 4, scale: 7, limitPadding: 100, runSpeed: 6 };
    const goalie = { x: canvas.width / 2, y: field.goalLineY, baseY: field.goalLineY, scale: 6, targetX: 0, targetY: 0, speedX: 0, speedY: 0, state: 'IDLE', rotation: 0 };

    // UI & Events
    const dial = document.getElementById('dial');
    const dialKnob = document.getElementById('dial-knob');
    const effectDisplay = document.getElementById('effect-display');
    const scoreGoalsEl = document.getElementById('score-goals');
    const scoreMissesEl = document.getElementById('score-misses');
    const missStreakEl = document.getElementById('miss-streak');
    const comboStreakEl = document.getElementById('combo-streak');
    const tigerBtn = document.getElementById('btn-tiger');

    tigerBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); });
    tigerBtn.addEventListener('click', () => {
        if (tigerUnlocked) {
            isTigerShot = true;
            tigerUnlocked = false; playerStats.streak = 0; updateUI();
        }
    });

    function updateUI() {
        missStreakEl.innerText = playerStats.streak;
        comboStreakEl.innerText = comboCounter;
        if (tigerUnlocked) { tigerBtn.classList.add('unlocked'); if(isTigerShot) tigerBtn.classList.add('active'); } 
        else { tigerBtn.classList.remove('unlocked'); tigerBtn.classList.remove('active'); }
    }

    dial.addEventListener('mousedown', (e) => { isDraggingDial = true; updateDial(e); });
    window.addEventListener('mousemove', (e) => { if(isDraggingDial) updateDial(e); });
    window.addEventListener('mouseup', () => { isDraggingDial = false; });

    function updateDial(e) {
        const rect = dial.getBoundingClientRect();
        const deltaX = e.clientX - (rect.left + rect.width / 2);
        let val = Math.max(-100, Math.min(100, (deltaX / 35) * 100));
        spinValue = Math.round(val);
        dialKnob.style.transform = `translate(-50%, -50%) rotate(${spinValue * 1.5}deg)`;
        effectDisplay.innerText = spinValue + "%";
        effectDisplay.style.color = spinValue < 0 ? "#FFC107" : spinValue > 0 ? "#29B6F6" : "white";
    }

    window.addEventListener('keydown', (e) => { if(e.key.toLowerCase() === 'a') keys.a = true; if(e.key.toLowerCase() === 'd') keys.d = true; });
    window.addEventListener('keyup', (e) => { if(e.key.toLowerCase() === 'a') keys.a = false; if(e.key.toLowerCase() === 'd') keys.d = false; });

    canvas.addEventListener('mousedown', (e) => {
        if (gameState !== 'AIMING' || isDraggingDial) return;
        const rect = canvas.getBoundingClientRect();
        let cy = e.clientY - rect.top;
        if (cy > canvas.height - 80) return;
        isCharging = true; chargePower = 0;
        shootTarget.x = e.clientX - rect.left; shootTarget.y = cy;
    });
    canvas.addEventListener('mousemove', (e) => { if (isCharging) { const rect = canvas.getBoundingClientRect(); shootTarget.x = e.clientX - rect.left; shootTarget.y = e.clientY - rect.top; } });
    window.addEventListener('mouseup', () => { if (isCharging && gameState === 'AIMING') startRun(shootTarget.x, shootTarget.y); isCharging = false; });

    function startRun(targetX, targetY) { shootTarget.x = targetX; shootTarget.y = targetY; gameState = 'RUNNING'; }
    function getZoneId(x, y) { let cx = canvas.width / 2; let cy = field.goalLineY - (field.goalHeight / 2); return (y < cy ? 0 : 1) * 2 + (x < cx ? 0 : 1); }

    function shootBall() {
        let targetX = shootTarget.x; let targetY = shootTarget.y;
        if (targetY > field.goalLineY) targetY = field.goalLineY - 5;
        gameState = 'SHOOTING';
        
        let spreadRadius = 0; let currentPower = isTigerShot ? 100 : chargePower;
        if (currentPower >= 50 && !isTigerShot) spreadRadius = (currentPower - 50) * 0.5;
        const maxErrorRadius = field.goalWidth * 0.12; 
        if (currentPower === 100 && !isTigerShot) spreadRadius = maxErrorRadius;
        else if (currentPower > 50 && !isTigerShot) spreadRadius = maxErrorRadius * ((currentPower - 50) / 50);

        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * spreadRadius;
        const finalTargetX = targetX + Math.cos(angle) * distance;
        const finalTargetY = targetY + Math.sin(angle) * distance;

        let totalSpeed = 16 + (12 * (currentPower / 100)); 
        if (isTigerShot) totalSpeed = 45; 

        const distZ = ball.groundY - field.goalLineY;
        const framesToGoal = distZ / (totalSpeed * 0.65);
        const dx = finalTargetX - ball.x;
        ball.vx = dx / framesToGoal; ball.shadowVy = -distZ / framesToGoal;
        const targetHeight = Math.max(0, field.goalLineY - finalTargetY);
        const gravity = 0.45;
        ball.vz = (targetHeight + 0.5 * gravity * Math.pow(framesToGoal, 2)) / framesToGoal;
        let spinRatio = spinValue / 100; if (isTigerShot) spinRatio = 0; 
        let powerFactor = currentPower / 100; let curveFactor = Math.pow(powerFactor, 2); 
        ball.ax = spinRatio * 0.75 * curveFactor;

        const predictedX = ball.x + (ball.vx * framesToGoal) + (0.5 * ball.ax * Math.pow(framesToGoal, 2));
        calculateGoalieReaction(finalTargetX, predictedX, finalTargetY, totalSpeed, currentPower);
        lastPlayerXAtShot = player.x;
    }

    function calculateGoalieReaction(initialTx, realTx, ty, shotSpeed, power) {
        if (!isGoalieActive) return;
        if (inTheZoneShotsLeft > 0) { goalie.targetX = goalie.x; goalie.speedX = 0; goalie.state = 'IDLE'; return; }

        const goalLeft = (canvas.width/2) - (field.goalWidth/2);
        const goalRight = (canvas.width/2) + (field.goalWidth/2);
        const inGoalRange = realTx > goalLeft && realTx < goalRight;
        
        let reactionSpeed = 14 + (Math.random() * 3);
        if (shotSpeed > 20) reactionSpeed *= 0.7;

        if (isTigerShot) { goalie.targetX = initialTx * 0.5; goalie.targetY = field.goalLineY; goalie.speedX = 5; goalie.speedY = 5; goalie.state = 'DIVING'; return; }

        let currentZone = -1;
        if (inGoalRange) currentZone = getZoneId(realTx, ty);
        let forcedSave = false;
        if (currentZone !== -1) {
            if (currentZone === lastZoneIndex) zoneRepetitionCount++; else { lastZoneIndex = currentZone; zoneRepetitionCount = 0; }
            if (zoneRepetitionCount >= 2) forcedSave = true;
        }

        let absSpin = Math.abs(spinValue);
        let cornerBonus = 1.0; let isCorner = false;
        const goalTop = field.goalLineY - field.goalHeight;
        if (ty < goalTop + 35 && (realTx < goalLeft + 35 || realTx > goalRight - 35)) isCorner = true;
        if (ty > field.goalLineY - 35 && (realTx < goalLeft + 35 || realTx > goalRight - 35)) isCorner = true;

        if (inGoalRange) {
            if (isCorner) {
                if (absSpin > 25 && power > 60) cornerBonus = 0.30; 
                else if (absSpin < 10) cornerBonus = 0.75; 
                else cornerBonus = 0.5; 
            } else {
                if (absSpin < 15) cornerBonus = 1.2; 
                else cornerBonus = 0.9; 
            }
        }
        reactionSpeed *= cornerBonus;
        let luck = Math.random() < 0.15; if (luck) reactionSpeed *= 0.5;

        let diveTarget = initialTx;
        if (Math.random() < 0.30 || absSpin < 10) { diveTarget = realTx; reactionSpeed *= 1.1; }

        if (forcedSave && !luck) {
            goalie.targetX = realTx; reactionSpeed = 50; 
            let jumpHeight = field.goalLineY - ty; if(jumpHeight < 0) jumpHeight=0; if(jumpHeight>150) jumpHeight=150;
            goalie.targetY = field.goalLineY - jumpHeight;
        } else if (inGoalRange || Math.abs(realTx - canvas.width/2) < field.goalWidth) {
            let error = (Math.random() - 0.5) * 120; if(luck) error *= 1.5;
            goalie.targetX = diveTarget + error;
            let jumpHeight = field.goalLineY - ty; if (jumpHeight < 0) jumpHeight = 0; if (jumpHeight > 150) jumpHeight = 150;
            goalie.targetY = field.goalLineY - jumpHeight;
        } else {
            goalie.targetX = diveTarget * 0.7; goalie.targetY = field.goalLineY - 20;
        }
        const lim = (canvas.width/2) + (field.goalWidth/2) + 20;
        goalie.targetX = Math.max(canvas.width - lim, Math.min(lim, goalie.targetX));
        goalie.speedX = reactionSpeed; goalie.speedY = reactionSpeed * 0.6; goalie.state = 'DIVING';
    }

    function update() {
        time += 0.2; 
        if (isCharging) { if (chargePower < 100) chargePower += 1.5; else chargePower = 100; }

        if (gameState === 'AIMING') {
            let moved = false;
            if (keys.a && player.x > player.limitPadding) { player.x -= player.speed; goalie.x += player.speed * 0.1; moved = true; }
            if (keys.d && player.x < canvas.width - player.limitPadding) { player.x += player.speed; goalie.x -= player.speed * 0.1; moved = true; }
            if(moved) lastZoneIndex = -1;
        }

        if (gameState === 'RUNNING') {
            let dx = ball.x - player.x; let dy = ball.y - player.y; let dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < 10) shootBall();
            else { player.x += (dx / dist) * player.runSpeed; player.y += (dy / dist) * player.runSpeed; }
        }

        if (gameState === 'SHOOTING') {
            ball.vx += ball.ax; ball.x += ball.vx; ball.groundX = ball.x; ball.groundY += ball.shadowVy; ball.z += ball.vz; ball.vz -= 0.45;
            if (ball.z < 0) ball.z = 0; ball.y = ball.groundY - ball.z;

            ball.trail.push({x: ball.x, y: ball.y, scale: ball.scale, life: 1.0});
            for(let i=ball.trail.length-1; i>=0; i--){ ball.trail[i].life -= 0.05; if(ball.trail[i].life <= 0) ball.trail.splice(i, 1); }

            if (!isTigerShot) ball.rotation += (0.2 + (Math.abs(spinValue)/100)); else ball.rotation += 0.8; 
            if (ball.scale > 0.4) ball.scale -= 0.012;

            if (goalie.state === 'DIVING' && isGoalieActive) {
                if (Math.abs(goalie.x - goalie.targetX) > goalie.speedX) goalie.x += (goalie.targetX > goalie.x) ? goalie.speedX : -goalie.speedX; else goalie.x = goalie.targetX;
                if (Math.abs(goalie.y - goalie.targetY) > goalie.speedY) goalie.y += (goalie.targetY > goalie.y) ? goalie.speedY : -goalie.speedY; else goalie.y = goalie.targetY;
                if (goalie.targetX < canvas.width/2) goalie.rotation = -0.15; else goalie.rotation = 0.15;
            }
            if (ball.groundY <= field.goalLineY) checkResult();
        }

        if (netOnFire) {
            if (Math.random() < 0.5) {
                let px = (canvas.width/2 - field.goalWidth/2) + Math.random() * field.goalWidth;
                fireParticles.push({x: px, y: field.goalLineY, vx: (Math.random()-0.5), vy: -Math.random()*3 - 1, life: 1.0, size: Math.random()*8+4});
            }
            for (let i = fireParticles.length - 1; i >= 0; i--) {
                let p = fireParticles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.02; if (p.life <= 0) fireParticles.splice(i, 1);
            }
        }

        // Ambient Flashes
        if(Math.random() < 0.03) flashes.push({x: Math.random()*canvas.width, y: Math.random()*field.horizonY, life: 1.0});
        for(let i=flashes.length-1; i>=0; i--) { flashes[i].life -= 0.1; if(flashes[i].life <= 0) flashes.splice(i, 1); }

        // Confetti
        if(isCrowdCelebrating && Math.random() < 0.3) {
            confetti.push({x: Math.random()*canvas.width, y: 0, vx: (Math.random()-0.5)*2, vy: Math.random()*3+2, color: `hsl(${Math.random()*360},100%,50%)`});
        }
        for(let i=confetti.length-1; i>=0; i--) {
            let c = confetti[i]; c.x += c.vx; c.y += c.vy; if(c.y > canvas.height) confetti.splice(i,1);
        }
    }

    function checkResult() {
        gameState = 'RESULT';
        const gl = (canvas.width/2) - (field.goalWidth/2);
        const gr = (canvas.width/2) + (field.goalWidth/2);
        const gt = field.goalLineY - field.goalHeight;
        const inGoal = ball.x > gl+5 && ball.x < gr-5 && ball.y > gt && ball.y < field.goalLineY;
        
        let gW = 12 * goalie.scale * 0.9; let gH = 6 * goalie.scale * 0.8; 
        let gVisualY = goalie.y - (gH/2); 
        let gHit = false;
        if (isGoalieActive) {
            if (Math.abs(ball.x - goalie.x) < gW/2 + ball.radius && Math.abs(ball.y - gVisualY) < gH/2 + ball.radius) gHit = true;
        }

        let msg="", cls="";
        if (gHit) { 
            msg="ATAJADA!"; cls="atajada"; playerStats.misses++; comboCounter = 0; 
            playerStats.streak++; if (playerStats.streak >= 5 && !isTigerShot) tigerUnlocked = true;
            if (inTheZoneShotsLeft > 0) inTheZoneShotsLeft = 0;
        } else if (inGoal) { 
            msg="GOLAZO!"; cls="gol"; playerStats.goals++; isCrowdCelebrating = true; playerStats.streak = 0;
            if (isTigerShot) { msg = "TIGER SHOT!!"; cls = "tiger-text"; netOnFire = true; } 
            if (inTheZoneShotsLeft > 0) { inTheZoneShotsLeft = 0; comboCounter = 0; } 
            else {
                comboCounter++;
                if (comboCounter >= 3) { inTheZoneShotsLeft = 1; msg = "EN LA ZONA!"; cls="zone"; }
            }
        } else { 
            msg="FUERA!"; cls="fuera"; playerStats.misses++; comboCounter = 0; 
            playerStats.streak++; if (playerStats.streak >= 5 && !isTigerShot) tigerUnlocked = true;
            if (inTheZoneShotsLeft > 0) inTheZoneShotsLeft = 0;
        }

        scoreGoalsEl.innerText = playerStats.goals;
        scoreMissesEl.innerText = playerStats.misses;
        updateUI();
        statusText.innerText = msg; statusText.className = "status-msg " + cls + " show";
        setTimeout(resetRound, 2500);
    }

    function resetRound() {
        gameState = 'AIMING'; isCharging = false; chargePower = 0; statusText.className = "status-msg";
        isCrowdCelebrating = false; isTigerShot = false; netOnFire = false; fireParticles = [];
        playerMovedInThisTurn = false; updateUI();
        player.x = canvas.width/2; player.y = canvas.height - 50; 
        ball.x = canvas.width/2; ball.y = field.penaltySpotY; ball.groundX = canvas.width/2; ball.groundY = field.penaltySpotY; ball.z = 0;
        ball.scale = 1; ball.vx=0; ball.vy=0; ball.vz=0; ball.shadowVy=0; ball.ax=0; ball.trail=[];
        goalie.x = canvas.width/2; goalie.y = goalie.baseY; goalie.state='IDLE'; goalie.rotation=0;
    }

    function drawAdBoards() {
        // Dibujar vallas debajo del p√∫blico
        let y = field.horizonY - 20;
        let adW = 120; 
        let count = Math.ceil(canvas.width / adW);
        for(let i=0; i<count; i++) {
            let ad = adBoards[i % adBoards.length];
            ctx.fillStyle = "#eee"; ctx.fillRect(i*adW, y, adW-2, 20);
            ctx.fillStyle = ad.color; ctx.fillRect(i*adW+2, y+2, adW-6, 16);
            // Texto est√°tico simple
            ctx.fillStyle = "white"; ctx.font = "bold 10px monospace"; ctx.textAlign = "center";
            ctx.fillText(ad.text, i*adW + adW/2, y+14);
        }
    }

    function drawNPCs() {
        // Seguridad
        for(let i=0; i<4; i++) {
            let x = 100 + i * 200;
            drawSprite(ctx, spriteGuard, x, field.horizonY - 10, 4);
        }
        // Fot√≥grafos
        drawSprite(ctx, spritePhoto, (canvas.width/2) - (field.goalWidth/2) - 40, field.goalLineY - 10, 4);
        drawSprite(ctx, spritePhoto, (canvas.width/2) + (field.goalWidth/2) + 40, field.goalLineY - 10, 4);
    }

    function drawAdvancedCrowd() {
        for(let row = 0; row < 8; row++) {
            ctx.fillStyle = (row % 2 === 0) ? "#263238" : "#37474f";
            ctx.fillRect(0, row * 20, canvas.width, 20);
            for(let col = 0; col < 60; col++) {
                let x = col * 16 + (row % 2) * 8; let baseX = x % canvas.width;
                let hue = (col * 33 + row * 77) % 360; let color = `hsl(${hue}, 70%, 50%)`;
                let yOffset = 0;
                if (isCrowdCelebrating) { let wave = Math.sin(time * 0.5 + col * 0.3); if(wave > 0) yOffset = wave * 6; } 
                else { let uniquePhase = col * 0.5 + row * 1.2; yOffset = Math.sin(time * 0.2 + uniquePhase) * 1.5; }
                let y = row * 20 + 10 - yOffset;
                ctx.fillStyle = color; ctx.fillRect(baseX, y, 10, 10);
                ctx.fillStyle = "#ffcc8d"; ctx.fillRect(baseX + 2, y - 6, 6, 6);
                if (isCrowdCelebrating && yOffset > 2) { ctx.fillStyle = "#ffcc8d"; ctx.fillRect(baseX - 2, y - 5, 2, 8); ctx.fillRect(baseX + 10, y - 5, 2, 8); }
            }
        }
    }

    function drawNetFire() {
        for (let p of fireParticles) {
            let alpha = p.life; ctx.fillStyle = `rgba(255, ${Math.floor(p.life*200)}, 0, ${alpha})`;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        }
    }

    function drawBallFancy() {
        ctx.save(); ctx.translate(ball.x, ball.y); ctx.scale(ball.scale, ball.scale); ctx.rotate(ball.rotation);
        let baseColor1 = "#fff"; let baseColor2 = "#ddd";
        if (isTigerShot) { baseColor1 = "#FF5252"; baseColor2 = "#D50000"; }
        else if (inTheZoneShotsLeft > 0) { baseColor1 = "#FFD700"; baseColor2 = "#FFA000"; }
        const rad = 12; let grad = ctx.createRadialGradient(-3, -3, 2, 0, 0, rad);
        grad.addColorStop(0, baseColor1); grad.addColorStop(1, baseColor2); 
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, rad, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = isTigerShot ? "#330000" : "#222"; ctx.beginPath();
        for (let i = 0; i < 5; i++) { let angle = (i * 72) * (Math.PI / 180); let r = 4; ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r); } ctx.fill();
        for (let i = 0; i < 5; i++) {
            let angle = (i * 72 + 36) * (Math.PI / 180); let dist = 9;
            ctx.beginPath(); ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 3.5, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = (inTheZoneShotsLeft > 0 || isTigerShot) ? "#FFC107" : "#ccc"; 
            ctx.lineWidth = 0.5; ctx.beginPath(); ctx.moveTo(Math.cos((i*72)*Math.PI/180)*4, Math.sin((i*72)*Math.PI/180)*4);
            ctx.lineTo(Math.cos(angle)*dist, Math.sin(angle)*dist); ctx.stroke();
        }
        if (isTigerShot) { ctx.shadowColor = "#FF3D00"; ctx.shadowBlur = 20; ctx.strokeStyle = "#FF3D00"; } 
        else if (inTheZoneShotsLeft > 0) { ctx.shadowColor = "#FFD700"; ctx.shadowBlur = 10; ctx.strokeStyle = "#FFFF00"; } 
        else { ctx.strokeStyle = "rgba(0,0,0,0.15)"; }
        ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, 0, rad, 0, Math.PI * 2); ctx.stroke();
        ctx.restore();
    }

    function draw() {
        ctx.clearRect(0,0, canvas.width, canvas.height);
        let grad = ctx.createLinearGradient(0,0,0,field.horizonY);
        grad.addColorStop(0, "#0a0e17"); grad.addColorStop(1, "#1a237e");
        ctx.fillStyle = grad; ctx.fillRect(0,0, canvas.width, field.horizonY);

        drawAdvancedCrowd();
        
        // Flashes
        for(let f of flashes) {
            ctx.fillStyle = `rgba(255,255,255,${f.life})`;
            ctx.beginPath(); ctx.arc(f.x, f.y, 3, 0, Math.PI*2); ctx.fill();
        }

        drawAdBoards();

        let grass = ctx.createLinearGradient(0, field.horizonY, 0, canvas.height);
        grass.addColorStop(0, "#1b5e20"); grass.addColorStop(1, "#388e3c");
        ctx.fillStyle = grass; ctx.fillRect(0, field.horizonY, canvas.width, canvas.height);

        drawNPCs();

        if(netOnFire) drawNetFire();

        // Linea Meta
        ctx.strokeStyle = "rgba(255,255,255,0.8)"; ctx.lineWidth=4; ctx.beginPath();
        ctx.moveTo(0, field.goalLineY); ctx.lineTo(canvas.width, field.goalLineY); ctx.stroke();

        // Area
        ctx.strokeStyle = "rgba(255,255,255,0.7)"; ctx.lineWidth = 3; ctx.beginPath();
        let areaDepth = 60; let areaBackHalf = (field.goalWidth / 2) + 50; let areaFrontHalf = areaBackHalf + 40; 
        ctx.moveTo(canvas.width/2 - areaBackHalf, field.goalLineY); ctx.lineTo(canvas.width/2 - areaFrontHalf, field.goalLineY + areaDepth); 
        ctx.lineTo(canvas.width/2 + areaFrontHalf, field.goalLineY + areaDepth); ctx.lineTo(canvas.width/2 + areaBackHalf, field.goalLineY); ctx.stroke();

        // Punto Penal
        ctx.fillStyle = "rgba(255,255,255,0.85)"; ctx.beginPath();
        ctx.ellipse(canvas.width / 2, field.penaltySpotY, 4, 2, 0, 0, Math.PI * 2); ctx.fill();

        // Arco
        let cx = canvas.width/2, gw = field.goalWidth/2, gh = field.goalHeight;
        ctx.strokeStyle = "#ccc"; ctx.lineWidth=5; ctx.beginPath();
        ctx.moveTo(cx-gw+20, field.goalLineY-gh+20); ctx.lineTo(cx+gw-20, field.goalLineY-gh+20);
        ctx.lineTo(cx+gw-20, field.goalLineY); ctx.moveTo(cx-gw+20, field.goalLineY-gh+20); ctx.lineTo(cx-gw+20, field.goalLineY); ctx.stroke();
        
        ctx.strokeStyle = "rgba(255,255,255,0.2)"; ctx.lineWidth=1; ctx.beginPath();
        for(let i=0; i<=12; i++) { let x=(cx-gw)+(field.goalWidth/12)*i; ctx.moveTo(x, field.goalLineY); ctx.lineTo(x+(i-6)*3, field.goalLineY-gh); }
        for(let i=0; i<=6; i++) { let y=field.goalLineY-(gh/6)*i; ctx.moveTo(cx-gw, y); ctx.lineTo(cx+gw, y); }
        ctx.stroke();

        ctx.strokeStyle = "#fff"; ctx.lineWidth=6; ctx.beginPath();
        ctx.moveTo(cx-gw, field.goalLineY); ctx.lineTo(cx-gw, field.goalLineY-gh);
        ctx.lineTo(cx+gw, field.goalLineY-gh); ctx.lineTo(cx+gw, field.goalLineY); ctx.stroke();

        let gSprite = goalie.state === 'DIVING' ? spriteGoalieDive : spriteGoalie;
        let spriteH = gSprite.length * goalie.scale;
        drawSprite(ctx, gSprite, goalie.x, goalie.y - (spriteH/2), goalie.scale, goalie.rotation);

        if(gameState === 'SHOOTING') {
            ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.beginPath(); ctx.ellipse(ball.groundX, ball.groundY, 10*ball.scale, 5*ball.scale, 0,0,Math.PI*2); ctx.fill();
            for(let t of ball.trail) { 
                let alpha = t.life * 0.4;
                if (isTigerShot) ctx.fillStyle = `rgba(255, 61, 0, ${alpha})`;
                else if (inTheZoneShotsLeft > 0) ctx.fillStyle = `rgba(255,215,0,${alpha})`; 
                else ctx.fillStyle = `rgba(255,255,255,${alpha})`;
                ctx.beginPath(); ctx.arc(t.x, t.y, 8*t.scale, 0, Math.PI*2); ctx.fill(); 
            }
        } else {
            ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.beginPath(); ctx.ellipse(ball.x, ball.y+10, 12, 6, 0,0,Math.PI*2); ctx.fill();
        }

        drawBallFancy();

        let pSprite = spritePlayer; 
        if (gameState === 'RUNNING') pSprite = (Math.floor(time) % 2 === 0) ? spritePlayerRun1 : spritePlayerRun2;
        else if (gameState === 'SHOOTING' || gameState === 'RESULT') pSprite = spritePlayerKick;

        let pSpriteH = pSprite.length * player.scale;
        drawSprite(ctx, pSprite, player.x, player.y - (pSpriteH/2) + 10, player.scale, 0);

        // Confetti
        for(let c of confetti) {
            ctx.fillStyle = c.color; ctx.fillRect(c.x, c.y, 4, 4);
        }

        // Vignette
        let gradV = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 300, canvas.width/2, canvas.height/2, 800);
        gradV.addColorStop(0, "rgba(0,0,0,0)");
        gradV.addColorStop(1, "rgba(0,0,0,0.6)");
        ctx.fillStyle = gradV; ctx.fillRect(0,0,canvas.width, canvas.height);

        if(gameState === 'AIMING' && isCharging) {
            const bw=100, bh=8, px=player.x-bw/2, py=player.y-140;
            ctx.fillStyle="rgba(0,0,0,0.8)"; ctx.fillRect(px-2, py-2, bw+4, bh+4);
            let col = chargePower>80 ? "#FF1744" : chargePower>50 ? "#FFEA00" : "#00E676";
            ctx.fillStyle=col; ctx.fillRect(px, py, bw*(chargePower/100), bh);
        }
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }
    loop();

</script>
</body>
</html>